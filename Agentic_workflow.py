# -*- coding: utf-8 -*-
"""Final Team3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SAkariEqCH_PjPh0aqg926WjyHLn2vhD
"""

!pip install langchain langgraph langchain_community langchainhub

pip install supabase

from langgraph.graph import graph

!pip install langchain_groq
from langchain_groq import ChatGroq

!pip install supabase

from google.colab import drive
drive.mount('/content/drive')

pip install langsmith

pip install python-dotenv

#MUNA
env_content = """
LANGSMITH_TRACING=true
LANGSMITH_ENDPOINT="https://api.smith.langchain.com"
LANGSMITH_API_KEY="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"
LANGSMITH_PROJECT="musc_app"
"""

with open(".env", "w") as f:
    f.write(env_content)

#MUNA
!pip install python-dotenv langsmith

from dotenv import load_dotenv
load_dotenv(".env")

### Final

import os
import requests
import pandas as pd
from langgraph.graph import StateGraph
from typing import Dict, Any
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import uuid
from random import sample
import json
from langsmith import traceable
from supabase import create_client, Client as SupabaseClient
from dotenv import load_dotenv

print(f"DEBUG: Current working directory: {os.getcwd()}")
success = load_dotenv("/content/.env")
print(f"DEBUG: load_dotenv('/content/.env') returned: {success}")
print(f"DEBUG: Does .env exist? {os.path.exists('/content/.env')}")
if not success or not os.path.exists("/content/.env"):
    print("‚ö†Ô∏è .env file not found. Creating a default one for this session.")
    with open("/content/.env", "w") as f:
        f.write("LANGSMITH_API_KEY=your_langsmith_key_here\n")
        f.write("LANGCHAIN_TRACING_V2=true\n")
        f.write("LANGCHAIN_PROJECT=pr-best-burden-66\n")
        f.write("GROQ_API_KEY=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\n")
    load_dotenv("/content/.env")
print(f"DEBUG: LANGSMITH_API_KEY: {os.getenv('LANGSMITH_API_KEY')}")
print(f"DEBUG: GROQ_API_KEY: {os.getenv('GROQ_API_KEY')}")

# Initialize Supabase Client
SUPABASE_URL = "https://nyexzxhkfizjojeabqrh.supabase.co"
SUPABASE_key = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im55ZXh6eGhrZml6am9qZWFicXJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA2OTcwMTAsImV4cCI6MjA1NjI3MzAxMH0.NQJyCpP5zFliuRkct1110OUYcRDlxIVaa-Dc0bo6urY"
supabase: SupabaseClient = create_client(SUPABASE_URL, SUPABASE_key)

# --- Step 1: Set API Key for Groq ---
os.environ["GROQ_API_KEY"] = os.getenv("GROQ_API_KEY", "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")

# --- Step 2: Load the Music Dataset ---
data_path = "/Tracks_and_Audio_Features_Dataset.csv"  # Ensure this is uploaded to /content
music_data = pd.read_csv(data_path)
features = ["artists", "track_name", "popularity", "duration_ms", "explicit", "danceability", "energy", "key",
            "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "time_signature"]
music_data = music_data[features]

# --- Step 3: Perform K-Means Clustering ---
clustering_features = ["popularity", "duration_ms", "explicit", "danceability", "energy", "key",
                       "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo"]
scaler = StandardScaler()
scaled_features = scaler.fit_transform(music_data[clustering_features])
kmeans = KMeans(n_clusters=6, random_state=42, n_init=10)
music_data['cluster'] = kmeans.fit_predict(scaled_features)
mood_mapping = {0: 'Energetic', 1: 'Chill', 2: 'Romantic', 3: 'Happy', 4: 'Sad', 5: 'Party'}
music_data['Mood_Level'] = music_data['cluster'].map(mood_mapping)

# --- Step 4: Define Agents (Nodes) ---
class StartAgent:
    def run(self, state):
        print("\nüéµ Hi! I can recommend music based on your mood!")
        return {"message": "Choose a mood: Happy, Sad, Energetic, Chill, Romantic, Party"}

class HumanInputAgent:
    def run(self, state):
        global memory_agent
        user_id = input("Enter your user ID (or type 'new' to generate a new one, 'clear' to reset): ").strip()
        if user_id.lower() == "clear":
            clear_id = input("Enter the user ID to clear (or 'all' for everything): ").strip()
            if clear_id.lower() == "all":
                memory_agent.clear_all_memory()
            else:
                clear_mood = input("Enter the mood to clear (or 'all' for all moods): ").strip().lower()
                if clear_mood == "all":
                    memory_agent.clear_user_memory(clear_id)
                else:
                    memory_agent.clear_user_mood_memory(clear_id, clear_mood)
            state["memory"] = memory_agent.memory
            user_id = input("Enter your user ID (or type 'new'): ").strip()
        if user_id.lower() == "new":
            user_id = str(uuid.uuid4())
            print(f"Your new user ID is: {user_id}")
        state["user_id"] = user_id
        mood = input("Enter your mood (Happy, Sad, Energetic, Chill, Romantic, Party): ").strip().capitalize()
        state["mood"] = mood
        return state

class MoodBasedRecommendationAgent:
    def run(self, state):
        mood = state["mood"]
        user_id = state["user_id"]
        memory = state.get("memory", {})
        previous_songs = memory.get(user_id, {}).get(mood.lower(), [])
        previous_song_set = {(s.get("track_name", "").lower(), s.get("artists", "").lower()) for s in previous_songs}
        mood_data = music_data[music_data["Mood_Level"] == mood]
        new_mood_data = mood_data[
            ~mood_data.apply(
                lambda row: (str(row["track_name"]).lower(), str(row["artists"]).lower()) in previous_song_set,
                axis=1
            )
        ]
        print(f"DEBUG: Found {len(new_mood_data)} new songs after filtering.")
        num_songs = min(15, len(new_mood_data))
        if num_songs == 0:
            print("‚ö†Ô∏è No new songs. Using fallback.")
            new_mood_data = mood_data
            num_songs = min(15, len(new_mood_data))
        sampled_songs = new_mood_data.sample(n=num_songs).to_dict(orient="records")
        state["filtered_songs"] = sampled_songs
        return state

class AIRecommendationAgent:
    @traceable
    def run(self, state):
        filtered_songs = state["filtered_songs"]
        mood = state["mood"]
        sampled_songs = filtered_songs
        song_list = [f"{s['track_name']} - {s['artists']}" for s in sampled_songs]
        print(f"DEBUG: Sending {len(sampled_songs)} mood-based songs to AI: {song_list}")

        prompt = (
            f"Given this list of {len(sampled_songs)} songs:\n{json.dumps(sampled_songs, indent=2)},\n"
            f"select exactly 10 songs for a '{mood}' mood. Format as 'Number. Song Title - Artist'."
        )


        try:
            API_KEY = os.getenv("GROQ_API_KEY")
            headers = {"Authorization": f"Bearer {API_KEY}", "Content-Type": "application/json"}
            payload = {
                "model": "llama-3.3-70b-versatile",
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 300
            }
            response = requests.post("https://api.groq.com/openai/v1/chat/completions", headers=headers, json=payload)
            response.raise_for_status()
            ai_msg = response.json()["choices"][0]["message"]["content"]
        except requests.exceptions.RequestException as e:
            ai_msg = "\n".join(
                f"{i+1}. {song['track_name']} - {song['artists']}"
                for i, song in enumerate(sample(filtered_songs, min(10, len(filtered_songs))))
            )
            print(f"API Request Failed: {e}")

        state["ai_recommendation"] = ai_msg
        print("\nüé∂ AI-Powered Music Recommendation:\n", ai_msg)
        return state

class MemoryAgent:
    def __init__(self, supabase_url, supabase_key):
        self.supabase = create_client(supabase_url, supabase_key)
        self.memory_file = "user_memory.json"
        self.memory = self.load_memory()

    def load_memory(self):
        if os.path.exists(self.memory_file):
            with open(self.memory_file, "r") as file:
                return json.load(file)
        return {}

    def save_memory(self):
        with open(self.memory_file, "w") as file:
            json.dump(self.memory, file)
        print(f"DEBUG: Saved memory to {self.memory_file}")

    def push_to_supabase(self, user_id, mood, recommendations):
        rows = [{"user_id": user_id, "mood": mood, "artists": s["artists"], "track_name": s["track_name"]} for s in recommendations]
        try:
            self.supabase.table("user_memo").insert(rows).execute()
            print(f"‚úÖ Pushed {len(rows)} recommendations to Supabase.")
        except Exception as e:
            print(f"‚ùå Supabase error: {e}")

    def clear_all_memory(self):
        self.memory = {}
        if os.path.exists(self.memory_file):
            os.remove(self.memory_file)
        self.supabase.table("user_memo").delete().neq("user_id", "").execute()

    def clear_user_memory(self, user_id):
        if user_id in self.memory:
            del self.memory[user_id]
        self.supabase.table("user_memo").delete().eq("user_id", user_id).execute()

    def clear_user_mood_memory(self, user_id, mood):
        if user_id in self.memory and mood in self.memory[user_id]:
            del self.memory[user_id][mood]
        self.supabase.table("user_memo").delete().eq("user_id", user_id).eq("mood", mood).execute()

    def run(self, state):
      user_id = state["user_id"]
      mood = state["mood"].lower()
      ai_recommendation = state["ai_recommendation"]

      if user_id not in self.memory:
          self.memory[user_id] = {}
      if mood not in self.memory[user_id]:
          self.memory[user_id][mood] = []


      ai_songs = [line.split(". ", 1)[-1] for line in ai_recommendation.split("\n")
                  if line.strip() and line.split(". ", 1)[0].isdigit()]
      parsed_songs = [dict(zip(["track_name", "artists"], song.split(" - ", 1)))
                      if " - " in song else {"track_name": song, "artists": "Unknown"}
                      for song in ai_songs]
      new_recommendations = [s for s in parsed_songs
                            if not any(p["track_name"] == s["track_name"] and p["artists"] == s["artists"]
                                      for p in self.memory[user_id][mood])]

      if new_recommendations:
          self.memory[user_id][mood].extend(new_recommendations)
          self.save_memory()
          self.push_to_supabase(user_id, mood, new_recommendations)
          print(f"‚ÑπÔ∏è Stored {len(new_recommendations)} new recommendations.")

      state["memory"] = self.memory
      return state

class OutputAgent:
    def run(self, state):
        print("\nüéµ Mood-Based Recommendations:")
        for i, song in enumerate(state.get("filtered_songs", []), 1):
            print(f"{i}. {song['track_name']} - {song['artists']}")
        print("\nüé∂ Final AI Recommendations:\n", state.get("ai_recommendation", "None"))
        print("\nüìö Memory Contents:")
        for user_id, moods in state.get("memory", {}).items():
            print(f"User: {user_id}")
            for mood, songs in moods.items():
                print(f"  Mood: {mood}")
                for i, song in enumerate(songs, 1):
                    print(f"    {i}. {song['track_name']} - {song['artists']}")
        state["quit"] = True
        return state

# --- Step 5: Define LangGraph Workflow ---
memory_agent = MemoryAgent(SUPABASE_URL, SUPABASE_key)
workflow = StateGraph(Dict[str, Any])
workflow.add_node("start", StartAgent().run)
workflow.add_node("input", HumanInputAgent().run)
workflow.add_node("filter", MoodBasedRecommendationAgent().run)
workflow.add_node("ai_recommendation", AIRecommendationAgent().run)
workflow.add_node("memory", memory_agent.run)
workflow.add_node("output", OutputAgent().run)
workflow.set_entry_point("start")
workflow.add_edge("start", "input")
workflow.add_edge("input", "filter")
workflow.add_edge("filter", "ai_recommendation")
workflow.add_edge("ai_recommendation", "memory")
workflow.add_edge("memory", "output")

print("\nüöÄ Mood-Based Music Recommendation System Started...")
executor = workflow.compile()
initial_state = {}
result = executor.invoke(initial_state)
print(f"DEBUG: Final state: {result}")